<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>SDN基本原理与OpenFlow协议分析 | Trenchance's Home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SDN基本原理与OpenFlow协议分析</h1><a id="logo" href="/.">Trenchance's Home</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SDN基本原理与OpenFlow协议分析</h1><div class="post-meta">2025-05-17</div><div class="post-content"><h1 id="实验一-SDN基本原理与OpenFlow协议分析"><a href="#实验一-SDN基本原理与OpenFlow协议分析" class="headerlink" title="实验一  SDN基本原理与OpenFlow协议分析"></a>实验一  SDN基本原理与OpenFlow协议分析</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解软件定义网络控制平面和数据平面相分离的原理。 </p>
<p>了解mininet 网络仿真平台以及开源SDN控制器Ryu的基本原理和功能。</p>
<p>掌握使用mininet平台自主构建一个较为复杂的网络拓扑，并建立与Ryu控制器的连接。  </p>
<p>掌握使用Wireshark工具抓取OpenFlow协议报文并进行分析。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>完成Mininet 及Ryu环境配置，了解软件定义网络控制平面和数据平面相分离的具体原理，了解Mininet及Ryu各自的基本原理与功能，以及两者之间连接的原理，了解OpenFlow协议的原理。  建立Mininet 与Ryu的连接并抓包分析OpenFlow协议。自主构建一个相对复杂的网络拓扑，至少包含3个以上的交换机，并针对这个网络进行连接的建立，以及后续的抓包和协议分析。 </p>
<h2 id="实验详细步骤"><a href="#实验详细步骤" class="headerlink" title="实验详细步骤"></a>实验详细步骤</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="前置配置"><a href="#前置配置" class="headerlink" title="前置配置"></a>前置配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">配置一下apt镜像</span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line">tianbjia</span><br><span class="line">增加镜像</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">然后按 Ctrl + O → 回车保存 → Ctrl + X 退出</span><br><span class="line"></span><br><span class="line">更新一下依赖库</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade -y</span><br><span class="line"></span><br><span class="line">安装pip</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3-pip</span><br><span class="line"></span><br><span class="line">which python</span><br><span class="line">如果输出为空，说明没有python命令</span><br><span class="line"></span><br><span class="line">which python3</span><br><span class="line">输出应为/usr/bin/python3</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python</span><br><span class="line">创建软链接</span><br><span class="line"></span><br><span class="line">which python</span><br><span class="line">输出/usr/bin/python</span><br><span class="line"></span><br><span class="line">python --version</span><br><span class="line">输出Python 3.8.10</span><br><span class="line"></span><br><span class="line">降级eventlet</span><br><span class="line">pip uninstall eventlet</span><br><span class="line">pip install eventlet==0.30.2</span><br></pre></td></tr></table></figure>



<h4 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">git clone https://gitee.com/derekwin/mininet.git</span><br><span class="line">cd mininet/util</span><br><span class="line">./install.sh -a</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517090835022.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">python3 -m pip install ryu</span><br><span class="line">echo &#x27;export PATH=$PATH:~/.local/bin&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>



<h4 id="环境检查"><a href="#环境检查" class="headerlink" title="环境检查"></a>环境检查</h4><p><img src="image-20250517090520805.png"></p>
<h3 id="建立Mininet与Ryu连接并抓包分析——基础示例"><a href="#建立Mininet与Ryu连接并抓包分析——基础示例" class="headerlink" title="建立Mininet与Ryu连接并抓包分析——基础示例"></a>建立Mininet与Ryu连接并抓包分析——基础示例</h3><h4 id="查看Ryu内置控制器"><a href="#查看Ryu内置控制器" class="headerlink" title="查看Ryu内置控制器"></a>查看Ryu内置控制器</h4><p>输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ~ -name &quot;simple_switch.py&quot; 2&gt;/dev/null</span><br><span class="line">cd /home/sdn/.local/lib/python3.8/site-packages/ryu/app/</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517091259827.png"></p>
<h4 id="启动Ryu控制器"><a href="#启动Ryu控制器" class="headerlink" title="启动Ryu控制器"></a>启动Ryu控制器</h4><p>输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ryu-manager simple_switch_13.py</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517091621247.png"></p>
<h4 id="利用Mininet工具构建网络拓扑"><a href="#利用Mininet工具构建网络拓扑" class="headerlink" title="利用Mininet工具构建网络拓扑"></a>利用Mininet工具构建网络拓扑</h4><p>拓扑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    h1[Host h1] --&gt; s1[Switch s1]</span><br><span class="line">    h2[Host h2] --&gt; s1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --controller=remote,ip=127.0.0.1,port=6633 --switch ovsk,protocols=OpenFlow13 --topo single,2</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517092132171.png"></p>
<h4 id="利用抓包工具Wireshark分析OpenFlow协议"><a href="#利用抓包工具Wireshark分析OpenFlow协议" class="headerlink" title="利用抓包工具Wireshark分析OpenFlow协议"></a>利用抓包工具Wireshark分析OpenFlow协议</h4><p>输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wireshark</span><br></pre></td></tr></table></figure>

<p>使用any模式抓包，结果如下：</p>
<p><img src="image-20250517092514807.png"></p>
<p><img src="image-20250517092648930.png"></p>
<h3 id="建立Mininet与Ryu连接并抓包分析——复杂拓扑"><a href="#建立Mininet与Ryu连接并抓包分析——复杂拓扑" class="headerlink" title="建立Mininet与Ryu连接并抓包分析——复杂拓扑"></a>建立Mininet与Ryu连接并抓包分析——复杂拓扑</h3><p>拓扑图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    h1[Host h1] --&gt; s1[Switch s1]</span><br><span class="line">    h2[Host h2] --&gt; s1</span><br><span class="line">    s1 --&gt; s2[Switch s2]</span><br><span class="line">    s2 --&gt; s3[Switch s3]</span><br><span class="line">    h3[Host h3] --&gt; s2</span><br><span class="line">    h4[Host h4] --&gt; s3</span><br><span class="line">    h5[Host h5] --&gt; s3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写拓扑python脚本：</p>
<p><img src="image-20250517094529770.png"></p>
<p>运行控制器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ryu-manager ryu.app.simple_switch_13</span><br></pre></td></tr></table></figure>

<p>在另一个终端运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --custom ~/Desktop/rzg_2022211181_topo.py --topo rzg --controller=remote,ip=127.0.0.1,port=6633 --switch ovsk,protocols=OpenFlow13</span><br></pre></td></tr></table></figure>

<p>检查连通性：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pingall</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517094711979.png"></p>
<p>抓包：</p>
<p><img src="image-20250517095239951.png"></p>
<p>注意：抓包可以使用过滤<code>openflow_v4</code>，抓包如果打不开，使用<code>sudo chown sdn:sdn *.pcapng</code>把root权限的抓包文件权限下放。</p>
<p>抓包分析详见实验分析一节。</p>
<h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><p>在分析过程中，由于我们设定了6633是控制器的端口，因此，我们可以在抓包时通过TCP协议的源端口和目的端口来确定该消息是发向控制器，或从控制器接收。</p>
<p>在我们这次抓包中，端口出现了45696、45710、45720和6633，其中6633默认是 Ryu 控制器监听的端口，45696、45710、45720是由 Mininet 中的交换机主动发起连接时分配的临时端口，即交换机（Open vSwitch）客户端端口。</p>
<p>我们通过TCP的源和目的端口确定数据流向。</p>
<p>在抓包时可以通过过滤<code>openflow_v4</code>便于观察。</p>
<p><img src="image-20250517105128071.png"></p>
<h3 id="宏观报文协作流程图"><a href="#宏观报文协作流程图" class="headerlink" title="宏观报文协作流程图"></a>宏观报文协作流程图</h3><p><img src="c.png"></p>
<h3 id="HELLO"><a href="#HELLO" class="headerlink" title="HELLO"></a>HELLO</h3><p><img src="image-20250517095744124.png"></p>
<h4 id="主要功能及作用分析"><a href="#主要功能及作用分析" class="headerlink" title="主要功能及作用分析"></a>主要功能及作用分析</h4><p>HELLO 报文是 OpenFlow 协议中的起始消息，用于交换机和控制器之间建立连接时进行协议版本协商。它标志着控制器和交换机之间控制通道的正式建立。HELLO 报文是双向的，控制器和交换机均需要主动发送，双方确认后才能继续后续的功能协商和能力请求。</p>
<h4 id="主要字段分析"><a href="#主要字段分析" class="headerlink" title="主要字段分析"></a>主要字段分析</h4><p>Version: 报文中显示为 1.3 (0x04)，表明该连接使用的是 OpenFlow 1.3 协议。</p>
<p> Type: OFPT_HELLO (0)，表示该消息类型为 HELLO。</p>
<p>Length: 报文长度，显示为 8 字节，表示标准的空载 HELLO 报文。</p>
<p>Transaction ID: 此字段为请求和响应配对提供唯一标识符，用于逻辑匹配。该值为 2116093918，是一个随机生成的无符号整数。</p>
<h4 id="报文出现阶段分析"><a href="#报文出现阶段分析" class="headerlink" title="报文出现阶段分析"></a>报文出现阶段分析</h4><p>HELLO 报文出现在 OpenFlow 控制通道初始化阶段，通常在控制器刚刚与交换机建立 TCP 连接后立即互相发送。该报文是双方握手的第一步，用于确定后续通信所使用的 OpenFlow 协议版本。如果双方版本不一致，则连接可能被拒绝。Wireshark 中显示的这条报文，是控制器（或交换机）在成功建立 TCP 握手后立即发出的，标志着OpenFlow协议通信正式开始。</p>
<h3 id="PORT-STATUS"><a href="#PORT-STATUS" class="headerlink" title="PORT_STATUS"></a>PORT_STATUS</h3><p><img src="image-20250517095920670.png"></p>
<h4 id="主要功能及作用分析-1"><a href="#主要功能及作用分析-1" class="headerlink" title="主要功能及作用分析"></a>主要功能及作用分析</h4><p>PORT_STATUS 报文用于通知控制器，交换机端口发生了变更。它的作用是保持控制器对物理网络状态的同步，及时获知端口的新增、删除或修改状态，以便进行路由重计算、流表更新或故障检测。它由交换机主动上报，不依赖控制器请求。</p>
<h4 id="主要字段分析-1"><a href="#主要字段分析-1" class="headerlink" title="主要字段分析"></a>主要字段分析</h4><p>Version: 1.3 (0x04)，表示使用 OpenFlow 1.3 协议</p>
<p>Type: OFPT_PORT_STATUS (12)，该报文类型编号为12，表示端口状态变更通知</p>
<p> Length: 80，报文长度</p>
<p>Transaction ID: 0，此字段可选，对PORT_STATUS通常不做事务配对</p>
<p> Reason: OFPPR_MODIFY (2)，表示端口状态发生修改</p>
<p>Port:  Port no: OFPP_LOCAL（本地端口编号）；Hw addr: 12:94:c7:af:23:43，为本地接口的 MAC 地址；Name: s1，为端口名称；Config、State、Current、Advertised、Supported、Peer：这些字段共同描述了端口的配置、状态和协商能力。</p>
<h4 id="报文出现阶段分析-1"><a href="#报文出现阶段分析-1" class="headerlink" title="报文出现阶段分析"></a>报文出现阶段分析</h4><p>PORT_STATUS 报文由交换机在端口状态发生变化时主动发出。常见的触发时机包括控制器刚连接后（交换机上报当前端口情况）、端口启用或禁用、链路断开、接口名更改等。它通常紧跟在 FEATURES_REPLY 报文之后出现，也可能在网络运行过程中动态出现，是动态状态感知机制的一部分。此处报文显示为修改类型，说明某个端口参数发生了更新。</p>
<h3 id="FEATURES-REQUEST"><a href="#FEATURES-REQUEST" class="headerlink" title="FEATURES_REQUEST"></a>FEATURES_REQUEST</h3><p><img src="image-20250517095856403.png"></p>
<h4 id="主要功能及作用分析-2"><a href="#主要功能及作用分析-2" class="headerlink" title="主要功能及作用分析"></a>主要功能及作用分析</h4><p>FEATURES_REQUEST 报文用于控制器主动向交换机询问其基本特征和能力信息。这是控制器获取交换机硬件状态、端口列表、支持能力（如组表、流表数目等）的关键步骤。控制器基于该报文的响应结果决定后续如何进行流表下发和路径控制等行为。</p>
<h4 id="主要字段分析-2"><a href="#主要字段分析-2" class="headerlink" title="主要字段分析"></a>主要字段分析</h4><p>Version: 1.3 (0x04)，表示使用 OpenFlow 1.3 协议</p>
<p> Type: OFPT_FEATURES_REQUEST (5)，表示该报文为功能请求报文，编号为5</p>
<p> Length: 8，表示该报文为无载荷的标准请求格式，仅包含头部</p>
<p>Transaction ID: 2116093919，为此次请求分配的唯一事务编号，控制器后续通过该 ID 匹配交换机返回的 FEATURES_REPLY 报文</p>
<h4 id="报文出现阶段分析-2"><a href="#报文出现阶段分析-2" class="headerlink" title="报文出现阶段分析"></a>报文出现阶段分析</h4><p>FEATURES_REQUEST 报文在控制器与交换机完成 HELLO 报文交换后立即发出，属于连接建立流程的第二阶段。控制器通过发送该报文来探测交换机的资源能力，确认其支持的特性，为后续的流表控制与端口管理提供基础信息。它是控制器获取网络拓扑与物理结构的第一步，在建立控制通道初期就会触发。</p>
<h3 id="FEATURES-REPLY"><a href="#FEATURES-REPLY" class="headerlink" title="FEATURES_REPLY"></a>FEATURES_REPLY</h3><p><img src="image-20250517095941696.png"></p>
<h4 id="主要功能及作用分析-3"><a href="#主要功能及作用分析-3" class="headerlink" title="主要功能及作用分析"></a>主要功能及作用分析</h4><p>FEATURES_REPLY 报文是交换机对控制器发送的 FEATURES_REQUEST 报文的响应。其主要作用是向控制器报告交换机的基本硬件能力和配置信息，包括 datapath ID、流表数量、端口缓冲区、支持的能力（如流统计、组表、表统计等），便于控制器根据这些信息作出决策，进行路径控制、策略下发等。</p>
<h4 id="主要字段分析-3"><a href="#主要字段分析-3" class="headerlink" title="主要字段分析"></a>主要字段分析</h4><p>Version: 1.3 (0x04)，表示使用的是 OpenFlow 1.3 协议版本</p>
<p>Type: OFPT_FEATURES_REPLY (6)，该类型编号为 6，表示功能应答报文</p>
<p>Length: 32，表示该报文长度为 32 字节</p>
<p>Transaction ID: 2116093919，用于对应之前控制器发送的 FEATURES_REQUEST 报文</p>
<p>datapath_id: 0x0000000000000001，交换机的唯一标识符（DPID）</p>
<p>n_buffers: 0，交换机可用的数据包缓存数量</p>
<p>n_tables: 254，交换机支持的流表数量</p>
<p>auxiliary_id: 0，标明这是主连接（不是辅助连接）</p>
<p>capabilities: 0x0000004f，该字段以比特位标识交换机支持的能力</p>
<h4 id="报文出现阶段分析-3"><a href="#报文出现阶段分析-3" class="headerlink" title="报文出现阶段分析"></a>报文出现阶段分析</h4><p>FEATURES_REPLY 报文出现在控制器与交换机建立连接初期，紧随 HELLO 和 FEATURES_REQUEST 之后。当控制器成功发送 FEATURES_REQUEST 后，交换机会立刻返回 FEATURES_REPLY，汇报自身能力。控制器根据这些信息构建全局拓扑图和流表策略，是控制平面了解数据平面的入口。该报文是双向能力同步的关键步骤之一。</p>
<h3 id="FLOW-MOD"><a href="#FLOW-MOD" class="headerlink" title="FLOW_MOD"></a>FLOW_MOD</h3><p><img src="image-20250517100021798.png"></p>
<h4 id="主要功能及作用分析-4"><a href="#主要功能及作用分析-4" class="headerlink" title="主要功能及作用分析"></a>主要功能及作用分析</h4><p>FLOW_MOD 报文用于控制器向交换机下发流表项，实现对数据平面转发行为的控制。控制器可以通过该报文添加、修改或删除指定规则的流表项，从而控制交换机对匹配数据包的处理行为，是SDN中“控制与转发分离”理念的直接体现。常用于响应 PACKET_IN 报文、部署策略路由等场景。</p>
<h4 id="主要字段分析-4"><a href="#主要字段分析-4" class="headerlink" title="主要字段分析"></a>主要字段分析</h4><p>Version: 1.3 (0x04)，表示使用 OpenFlow 1.3 协议</p>
<p>Type: OFPT_FLOW_MOD (14)，该类型编号为14，表示流表修改报文</p>
<p>Length: 80，报文长度为 80 字节</p>
<p>Transaction ID: 2116093921，用于与控制器逻辑流程匹配</p>
<p>Cookie &#x2F; Cookie mask: 用于标识和管理特定流表项（可用于后续删除或统计）</p>
<p>Table ID: 0，表示将规则写入主流表</p>
<p> Command: OFPFC_ADD (0)，表示本次操作为新增一条流表项</p>
<p>Idle timeout &#x2F; Hard timeout: 0，表示该流表项无超时限制</p>
<p> Priority: 0，该规则优先级</p>
<p> Buffer ID: OFP_NO_BUFFER，表示不缓存任何数据包</p>
<p>Out port &#x2F; Out group: 0，表示没有目标端口或组设定（由 action 决定）</p>
<p>Flags: 全为 False，表示不额外设置统计或清除行为</p>
<p>Match 部分：</p>
<ul>
<li>Type: OFPMT_OXM，OpenFlow扩展匹配字段类型</li>
</ul>
<p>Instruction 部分：</p>
<ul>
<li>Type: OFPIT_APPLY_ACTIONS，应用的动作指令类型</li>
<li>Action：表示转发动作</li>
</ul>
<h4 id="报文出现阶段分析-4"><a href="#报文出现阶段分析-4" class="headerlink" title="报文出现阶段分析"></a>报文出现阶段分析</h4><p>FLOW_MOD 报文通常出现在控制器接收到 PACKET_IN 报文之后，用于向交换机下发具体的流表处理规则。它也可由控制器主动部署策略时直接下发。该报文是整个 OpenFlow 协议中实现转发控制的核心机制，决定了数据包如何被交换机匹配和处理，是 SDN 控制器调度能力的核心体现。在实际网络运行中，会频繁出现。</p>
<h3 id="PACKET-IN"><a href="#PACKET-IN" class="headerlink" title="PACKET_IN"></a>PACKET_IN</h3><p><img src="image-20250517100129873.png"></p>
<h4 id="主要功能及作用分析-5"><a href="#主要功能及作用分析-5" class="headerlink" title="主要功能及作用分析"></a>主要功能及作用分析</h4><p>PACKET_IN 报文用于当交换机接收到一个数据包，但其不匹配当前流表中任何规则时，将该数据包上送给控制器进行处理。此机制是 SDN 中实现“集中控制”的关键之一。控制器接收到 PACKET_IN 后可以决定是否下发新流表（FLOW_MOD）或通过 PACKET_OUT 直接处理该数据包。</p>
<h4 id="主要字段分析-5"><a href="#主要字段分析-5" class="headerlink" title="主要字段分析"></a>主要字段分析</h4><p>Version: 1.3 (0x04)，OpenFlow 1.3 协议版本</p>
<p> Type: OFPT_PACKET_IN (10)，表示该报文为数据上送类型</p>
<p>Length: 128，报文总长度</p>
<p>Transaction ID: 0，通常此报文为通知型，不依赖事务匹配</p>
<p>Buffer ID: OFP_NO_BUFFER，表示该数据包未缓存在交换机内</p>
<p>Reason: OFPR_NO_MATCH (0)，表示该数据包未匹配任何流表项被转发给控制器</p>
<p>Table ID: 0，指示该数据包是在哪个流表中未命中</p>
<p> Match: 表示触发此 PACKET_IN 的匹配字段</p>
<ul>
<li>Type: OFPMT_OXM (1)，使用 OXM 匹配字段格式</li>
<li>Field: OFPXMT_OFB_IN_PORT (0)，表示匹配入端口为 port 3（即该数据包是从端口3进来的）</li>
</ul>
<p>Data 部分：</p>
<ul>
<li>Ethernet II: 数据包的原始二层帧，包含 src MAC 和 dst MAC</li>
<li>IPv6: 显示这是一个基于 IPv6 的数据包</li>
<li>ICMPv6: 显示该数据包为 ICMPv6 协议的邻居请求报文（Neighbor Solicitation）</li>
</ul>
<h4 id="报文出现阶段分析-5"><a href="#报文出现阶段分析-5" class="headerlink" title="报文出现阶段分析"></a>报文出现阶段分析</h4><p>PACKET_IN 报文出现在交换机未能找到匹配流表项处理某个入包时。此时，交换机将该包或包头（依据配置）封装为 PACKET_IN 上送给控制器，等待控制器决策。它通常是网络中通信刚启动时，尚未学习 MAC、未建立路径时的首个动作，是控制器下发 FLOW_MOD 的直接前提。在本抓包中，此报文为 ICMPv6 邻居发现请求，由于未匹配流表，因此触发 PACKET_IN。</p>
<h3 id="PACKET-OUT"><a href="#PACKET-OUT" class="headerlink" title="PACKET_OUT"></a>PACKET_OUT</h3><p><img src="image-20250517100143253.png"></p>
<h4 id="主要功能及作用分析-6"><a href="#主要功能及作用分析-6" class="headerlink" title="主要功能及作用分析"></a>主要功能及作用分析</h4><p>PACKET_OUT 报文用于控制器将原始数据包从指定端口下发回交换机处理，用于实现立即的数据转发。它通常在控制器收到 PACKET_IN 报文后，决定处理策略时使用。控制器可以通过 PACKET_OUT 指定将数据包发送到某个端口，广播出去，或丢弃等，是 SDN 控制器主动干预转发行为的重要方式。</p>
<h4 id="主要字段分析-6"><a href="#主要字段分析-6" class="headerlink" title="主要字段分析"></a>主要字段分析</h4><p>Version: 1.3 (0x04)，表示使用 OpenFlow 1.3 协议</p>
<p> Type: OFPT_PACKET_OUT (13)，报文类型编号为 13，表示下发原始数据包</p>
<p>Length: 126，总长度为 126 字节</p>
<p>Transaction ID: 2623750473，为此次下发操作分配的事务编号</p>
<p> Buffer ID: OFP_NO_BUFFER，表示不使用交换机缓存（控制器主动携带数据）</p>
<p>In port: 3，表示该数据包原始来源为端口 3</p>
<p>Actions length: 16，表示动作部分占 16 字节</p>
<p>Action 部分：</p>
<ul>
<li><p>Type: OFPAT_OUTPUT (0)，动作类型为输出</p>
</li>
<li><p>Port: OFPP_FLOOD，表示该数据包将以广播方式从所有端口发送（排除 ingress 端口）</p>
</li>
<li><p>Max length: 65509，最大传输长度</p>
</li>
</ul>
<p>Data 部分：</p>
<ul>
<li><p>Ethernet II: 源 MAC 为 9a:62:e4:0c:19:f2，目的为 IPv6 组播地址 33:33:ff:0c:19:f2</p>
</li>
<li><p>IPv6: 源 IPv6 为 ::，目标为 ff02::1:ff0c:19f2</p>
</li>
<li><p>ICMPv6: 协议类型为邻居发现（Neighbor Solicitation）</p>
</li>
</ul>
<h4 id="报文出现阶段分析-6"><a href="#报文出现阶段分析-6" class="headerlink" title="报文出现阶段分析"></a>报文出现阶段分析</h4><p>PACKET_OUT 报文通常出现在交换机上送一个未匹配数据包后，控制器决定如何处理该数据包时。它可以用于转发 ARP 请求、ICMPv6 邻居发现等广播类数据包，也可直接实现控制器主导的转发行为。在本抓包中，该 PACKET_OUT 报文是对 PACKET_IN 中 IPv6 邻居请求的响应，控制器选择将其通过广播的方式发出，实现链路层地址发现。此过程体现了控制器对数据包的直接干预和下发能力。</p>
<h2 id="实验过程中遇到的问题及解决办法"><a href="#实验过程中遇到的问题及解决办法" class="headerlink" title="实验过程中遇到的问题及解决办法"></a>实验过程中遇到的问题及解决办法</h2><h3 id="apt下载速度慢"><a href="#apt下载速度慢" class="headerlink" title="apt下载速度慢"></a>apt下载速度慢</h3><p>解决方案：配置镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line">tianbjia</span><br><span class="line">增加镜像</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">然后按 Ctrl + O → 回车保存 → Ctrl + X 退出</span><br></pre></td></tr></table></figure>



<h3 id="Ryu安装失败"><a href="#Ryu安装失败" class="headerlink" title="Ryu安装失败"></a>Ryu安装失败</h3><p>首先，建立python的软链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">which python</span><br><span class="line">如果输出为空，说明没有python命令</span><br><span class="line"></span><br><span class="line">which python3</span><br><span class="line">输出应为/usr/bin/python3</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python</span><br><span class="line">创建软链接</span><br><span class="line"></span><br><span class="line">which python</span><br><span class="line">输出/usr/bin/python</span><br><span class="line"></span><br><span class="line">python --version</span><br><span class="line">输出Python 3.8.10</span><br></pre></td></tr></table></figure>

<p>其次，需要安装pip</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure>

<p>然后进行eventlet降级</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall eventlet</span><br><span class="line">pip install eventlet==0.30.2</span><br></pre></td></tr></table></figure>



<h3 id="Wireshark抓包文件打不开"><a href="#Wireshark抓包文件打不开" class="headerlink" title="Wireshark抓包文件打不开"></a>Wireshark抓包文件打不开</h3><p>使用<code>sudo chown sdn:sdn *.pcapng</code>把root权限的抓包文件权限下放。</p>
<h3 id="Wireshark使用openflow过滤发现没有报文"><a href="#Wireshark使用openflow过滤发现没有报文" class="headerlink" title="Wireshark使用openflow过滤发现没有报文"></a>Wireshark使用openflow过滤发现没有报文</h3><p>改为过滤<code>openflow_v4</code>。</p>
<h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>本次实验通过使用 Wireshark 抓包工具，对 OpenFlow 协议中的关键报文类型进行逐个观察与分析，包括 HELLO、FEATURES_REQUEST、FEATURES_REPLY、PORT_STATUS、FLOW_MOD、PACKET_IN、PACKET_OUT 等。在实验过程中，我深刻理解了控制器与交换机之间的通信机制，以及这些协议报文在 SDN 架构中所扮演的角色。</p>
<p>首先，在观察 HELLO 报文时，我明确了其作为控制通道建立的起点作用。实验中控制器和交换机在 TCP 握手成功后立即互发 HELLO 报文，用于协商 OpenFlow 协议版本，这是整个会话建立的前提。</p>
<p>随后，通过分析 FEATURES_REQUEST 和 FEATURES_REPLY 报文，我了解到控制器通过请求查询交换机的基本能力，而交换机通过应答反馈自身的资源情况，包括支持的流表数量、端口能力、流统计等。这一过程体现了控制器对网络拓扑和状态的感知能力，为后续流表策略下发奠定基础。</p>
<p>PORT_STATUS 报文展示了交换机在端口状态变化时，主动向控制器通告的能力。在抓包中，我观察到交换机在连接建立后会自动上报本地端口信息，这有助于控制器感知链路层的变化，及时调整策略。</p>
<p>在流表控制阶段，通过观察FLOW_MOD 报文，我学会了如何通过控制器下发匹配规则，包括设置匹配字段、优先级、超时时间及动作等内容，从而控制数据包的转发行为。</p>
<p>而当交换机接收到未匹配的报文时，会触发 PACKET_IN 报文将其上送控制器，这是 SDN 控制机制的一个核心体现。</p>
<p>整个实验不仅加深了我对 OpenFlow 报文结构和作用的理解，更让我切实体验了“集中控制、转发分离”的 SDN 网络运行机制。实验中抓包分析的细节操作也锻炼了我的协议解析和网络调试能力。</p>
<h1 id="实验二-OpenFlow流表操作实践"><a href="#实验二-OpenFlow流表操作实践" class="headerlink" title="实验二  OpenFlow流表操作实践"></a>实验二  OpenFlow流表操作实践</h1><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解OpenFlow协议的基本原理及流表结构。</p>
<p>熟悉流表项的增删改查操作及其对数据转发的影响。</p>
<p>通过主机间连通状况验证流表行为。</p>
<h2 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h2><p>建立Mininet 与Ryu的连接，实现简单的二层交换功能。</p>
<p>通过命令行工具curl进行下发、查看、删除流表操作。</p>
<p>通过Mininet 指令和ryu命令行内容验证流表匹配与数据包处理。 </p>
<h2 id="实验详细步骤-1"><a href="#实验详细步骤-1" class="headerlink" title="实验详细步骤"></a>实验详细步骤</h2><h3 id="启动实验环境"><a href="#启动实验环境" class="headerlink" title="启动实验环境"></a>启动实验环境</h3><p>安装 curl。curl 是一个开源命令行工具，通过各类网络协议传输数据，支持 get、post、delete 等 http 方法，本实验中用于进行下发、查看、删除流表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517150631831.png"></p>
<p>终端1启动Ryu控制器。它加载了两个 Python 模块， <code>ryu.app.simple_switch_13</code>实现一个基于 OpenFlow 1.3 的二层交换机，会自动学习主机的 MAC 地址，并下发对应的流表规则。 <code>ryu.app.ofctl_rest</code>提供 REST API 接口，支持使用 <code>curl</code> 发 HTTP 请求来管理流表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ryu-manager ryu.app.ofctl_rest ryu.app.simple_switch_13</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517150816292.png"></p>
<p>终端2启动Mininet拓扑，创建两层树形拓扑。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --controller remote --topo tree,depth=2</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517150847043.png"></p>
<p>拓扑图如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    s1[Switch s1] --&gt; s2[Switch s2]</span><br><span class="line">    s1 --&gt; s3[Switch s3]</span><br><span class="line">    </span><br><span class="line">    s2[Switch s2] --&gt; h1[Host h1]</span><br><span class="line">    s2 --&gt; h2[Host h2]</span><br><span class="line">    s3 --&gt; h3[Host h3]</span><br><span class="line">    s3 --&gt; h4[Host h4]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用net查看拓扑</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517150912599.png"></p>
<h3 id="实现二层交换"><a href="#实现二层交换" class="headerlink" title="实现二层交换"></a>实现二层交换</h3><p>测试连通。Ryu 的 simple_switch_13 已经实现了二层自学习交换功能，无需额外配置即可连通。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pingall</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517151321854.png"></p>
<p>在终端3查看交换机s1流表，已经自动学习MAC地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/stats/flow/1</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517151356934.png"></p>
<p>不美观，我们可以用 <code>python3 -m json.tool</code> 让输出加上 pretty print。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/stats/flow/1 | python3 -m json.tool</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517151825276.png"></p>
<p>（截图很长，这里不放全部内容了）</p>
<p>另一种查看s1流表的方式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ovs-ofctl -O OpenFlow13 dump-flows s1</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517151432236.png"></p>
<h3 id="下发流表，流表匹配与数据包处理"><a href="#下发流表，流表匹配与数据包处理" class="headerlink" title="下发流表，流表匹配与数据包处理"></a>下发流表，流表匹配与数据包处理</h3><p>删除s1的所有流表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123;&quot;dpid&quot;:1,&quot;match&quot;:&#123;&#125;&#125;&#x27; http://127.0.0.1:8080/stats/flowentry/delete</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517152116646.png"></p>
<p>再次查看s1流表发现为空</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/stats/flow/1</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517152131043.png"></p>
<p>尝试 pingall，仅有h1和h2之间、h3和h4之间能ping通。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pingall</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517152331901.png"></p>
<p>查看h1的mac地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 ifconfig</span><br></pre></td></tr></table></figure>

<p>查看h3的mac地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h3 ifconfig</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517152401607.png"></p>
<p>记录一下MAC地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b2:84:cc:df:e0:53</span><br><span class="line">42:f6:00:b0:c6:6f</span><br></pre></td></tr></table></figure>



<p>给s1添加一个流表，源地址h1，目标地址h3。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123; </span><br><span class="line">  &quot;dpid&quot;: 1, </span><br><span class="line">  &quot;priority&quot;: 100, </span><br><span class="line">  &quot;match&quot;: &#123; </span><br><span class="line">    &quot;in_port&quot;: 1, </span><br><span class="line">    &quot;dl_src&quot;: &quot;b2:84:cc:df:e0:53&quot;, </span><br><span class="line">    &quot;dl_dst&quot;: &quot;42:f6:00:b0:c6:6f&quot; </span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;actions&quot;: [&#123;&quot;type&quot;: &quot;OUTPUT&quot;, &quot;port&quot;: 2&#125;] </span><br><span class="line">&#125;&#x27; http://127.0.0.1:8080/stats/flowentry/add</span><br></pre></td></tr></table></figure>

<p>这个命令的含义是：如果有从端口1进来的数据包，源MAC是 h1（<code>b2:84:cc:df:e0:53</code>），目标MAC是 h3（<code>42:f6:00:b0:c6:6f</code>），就将它转发到端口2。</p>
<p><img src="image-20250517152802067.png"></p>
<p>尝试ping，依然无法连通</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pingall</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517152914379.png"></p>
<p><img src="image-20250517152858628.png"></p>
<p>给s1添加一个用于h1广播的流表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123; </span><br><span class="line">  &quot;dpid&quot;: 1, </span><br><span class="line">  &quot;priority&quot;: 100, </span><br><span class="line">  &quot;match&quot;: &#123; </span><br><span class="line">    &quot;in_port&quot;: 1, </span><br><span class="line">    &quot;dl_src&quot;: &quot;b2:84:cc:df:e0:53&quot;, </span><br><span class="line">    &quot;dl_dst&quot;: &quot;ff:ff:ff:ff:ff:ff&quot; </span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;actions&quot;: [&#123;&quot;type&quot;: &quot;OUTPUT&quot;, &quot;port&quot;: 2&#125;] </span><br><span class="line">&#125;&#x27; http://127.0.0.1:8080/stats/flowentry/add</span><br></pre></td></tr></table></figure>



<p>给s1添加一个流表，源地址h3，目标地址h1，这里注意端口号！！！<code>in_port</code> 表示数据包是从交换机的哪一个端口进入的，在 OpenFlow 中，交换机有多个端口（比如 <code>s1-eth1</code>, <code>s1-eth2</code> 等），每个端口都有一个编号（如 1、2、3…），控制器可以设置“只有从特定端口进入的数据包”才匹配这条规则。同时，发出端口也需要配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123; </span><br><span class="line">  &quot;dpid&quot;: 1, </span><br><span class="line">  &quot;priority&quot;: 100, </span><br><span class="line">  &quot;match&quot;: &#123; </span><br><span class="line">    &quot;in_port&quot;: 2, </span><br><span class="line">    &quot;dl_src&quot;: &quot;42:f6:00:b0:c6:6f&quot;, </span><br><span class="line">    &quot;dl_dst&quot;: &quot;b2:84:cc:df:e0:53&quot; </span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;actions&quot;: [&#123;&quot;type&quot;: &quot;OUTPUT&quot;, &quot;port&quot;: 1&#125;] </span><br><span class="line">&#125;&#x27; http://127.0.0.1:8080/stats/flowentry/add</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517160007904.png"></p>
<p>尝试ping，成功连通h1-h3。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pingall</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517160047750.png"></p>
<p>查看s1的流表项，包含我们刚才配置的三项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ovs-ofctl -O OpenFlow13 dump-flows s1</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517160111585.png"></p>
<h2 id="实验分析-1"><a href="#实验分析-1" class="headerlink" title="实验分析"></a>实验分析</h2><h3 id="思考题1：两种查看流表的方式有什么不同？这些流表表示了什么信息？"><a href="#思考题1：两种查看流表的方式有什么不同？这些流表表示了什么信息？" class="headerlink" title="思考题1：两种查看流表的方式有什么不同？这些流表表示了什么信息？"></a>思考题1：两种查看流表的方式有什么不同？这些流表表示了什么信息？</h3><h4 id="使用-REST-API（-curl-命令）"><a href="#使用-REST-API（-curl-命令）" class="headerlink" title="使用 REST API（ curl 命令）"></a>使用 REST API（ curl 命令）</h4><p>  <code>curl http://127.0.0.1:8080/stats/flow/1</code> 通过 HTTP 请求向控制器查询流表信息。这种方式展示的数据结构是 JSON。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cookie&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;idle_timeout&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hard_timeout&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;byte_count&quot;</span><span class="punctuation">:</span> <span class="number">238</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;duration_sec&quot;</span><span class="punctuation">:</span> <span class="number">1773</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;duration_nsec&quot;</span><span class="punctuation">:</span> <span class="number">916000000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;packet_count&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;length&quot;</span><span class="punctuation">:</span> <span class="number">104</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;flags&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;OUTPUT:2&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;in_port&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dl_src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b2:84:cc:df:e0:53&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dl_dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;42:f6:00:b0:c6:6f&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;table_id&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>priority</code></td>
<td>整数</td>
<td>匹配规则的优先级，数值越大优先级越高</td>
</tr>
<tr>
<td><code>cookie</code></td>
<td>十六进制整数</td>
<td>控制器定义的标识符，用于标记该流表规则的用途或来源，可在删除流表时筛选使用</td>
</tr>
<tr>
<td><code>idle_timeout</code></td>
<td>秒</td>
<td>若一段时间未命中此规则（空闲），则自动删除。0 表示永不超时</td>
</tr>
<tr>
<td><code>hard_timeout</code></td>
<td>秒</td>
<td>自规则创建起超过该时间后强制删除。0 表示永不超时</td>
</tr>
<tr>
<td><code>byte_count</code></td>
<td>字节数</td>
<td>统计已匹配的数据总字节数</td>
</tr>
<tr>
<td><code>packet_count</code></td>
<td>个</td>
<td>统计已匹配的数据包总数</td>
</tr>
<tr>
<td><code>duration_sec</code></td>
<td>秒</td>
<td>流表项已存在的时间（秒）</td>
</tr>
<tr>
<td><code>duration_nsec</code></td>
<td>纳秒</td>
<td>精确补充 <code>duration_sec</code>，用于统计分析</td>
</tr>
<tr>
<td><code>length</code></td>
<td>字节数</td>
<td>该流表项结构在控制器中的长度（数据结构 size），非必要字段</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>整数（位图）</td>
<td>通常为 0，保留位，用于标记如 <code>SEND_FLOW_REM</code> 等特殊操作</td>
</tr>
<tr>
<td><code>actions</code></td>
<td>列表</td>
<td>匹配后执行的动作（如 <code>OUTPUT:2</code> 表示输出到端口 2）</td>
</tr>
<tr>
<td><code>match</code></td>
<td>对象</td>
<td>匹配字段列表（如 <code>in_port</code>, <code>dl_src</code>, <code>dl_dst</code> 等）</td>
</tr>
<tr>
<td><code>table_id</code></td>
<td>整数</td>
<td>该规则所在的表号（通常为默认 <code>0</code>）</td>
</tr>
</tbody></table>
<h4 id="使用-OVS-命令行（ovs-ofctl）"><a href="#使用-OVS-命令行（ovs-ofctl）" class="headerlink" title="使用 OVS 命令行（ovs-ofctl）"></a>使用 OVS 命令行（ovs-ofctl）</h4><p>  <code>sudo ovs-ofctl -O OpenFlow13 dump-flows s1</code> 是直接与本地 Open vSwitch 实例交互，输出为文本格式，匹配字段展示有限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie=0x0, duration=86.409s, table=0, n_packets=3, n_bytes=238, priority=100,in_port=&quot;s1-eth1&quot;,dl_src=b2:84:cc:df:e0:53,dl_dst=42:f6:00:b0:c6:6f actions=output:&quot;s1-eth2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>cookie</code></td>
<td>控制器可设置的标识符，用于标记这条流表的来源或用途</td>
</tr>
<tr>
<td><code>duration</code></td>
<td>该流表项自安装后运行的时间（秒）</td>
</tr>
<tr>
<td><code>table</code></td>
<td>所属的表号，一般默认是 table 0</td>
</tr>
<tr>
<td><code>n_packets</code></td>
<td>命中该规则的数据包总数</td>
</tr>
<tr>
<td><code>n_bytes</code></td>
<td>命中该规则的所有数据包字节总数</td>
</tr>
<tr>
<td><code>priority</code></td>
<td>流表的优先级，越大优先匹配</td>
</tr>
<tr>
<td><code>in_port</code></td>
<td>匹配进入的交换机端口</td>
</tr>
<tr>
<td><code>dl_src</code></td>
<td>以太网源 MAC 地址</td>
</tr>
<tr>
<td><code>dl_dst</code></td>
<td>以太网目的 MAC 地址</td>
</tr>
<tr>
<td><code>actions</code></td>
<td>命中后采取的动作，如 <code>output:&quot;s1-eth2&quot;</code> 表示转发到该端口</td>
</tr>
</tbody></table>
<h3 id="思考题2：s1流表空的时候，仅有h1和h2之间、h3和h4之间能ping通的原因。"><a href="#思考题2：s1流表空的时候，仅有h1和h2之间、h3和h4之间能ping通的原因。" class="headerlink" title="思考题2：s1流表空的时候，仅有h1和h2之间、h3和h4之间能ping通的原因。"></a>思考题2：s1流表空的时候，仅有h1和h2之间、h3和h4之间能ping通的原因。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    s1[Switch s1] --&gt; s2[Switch s2]</span><br><span class="line">    s1 --&gt; s3[Switch s3]</span><br><span class="line">    </span><br><span class="line">    s2[Switch s2] --&gt; h1[Host h1]</span><br><span class="line">    s2 --&gt; h2[Host h2]</span><br><span class="line">    s3 --&gt; h3[Host h3]</span><br><span class="line">    s3 --&gt; h4[Host h4]</span><br></pre></td></tr></table></figure>

<p>我们只清空了 s1 的流表项，并没有清除 s2 与 s3 上的流表，因此：s2 内部的 h1 与 h2 之间通信不需要经过 s1，仍能依靠原本保留的流表进行转发；同理，h3 与 h4 也都接入 s3，通信不依赖 s1，也能成功。</p>
<p>而 h1 与 h3 之间通信 必须经过 s2 → s1 → s3，而中间经过的 s1 已经没有任何流表项，所以数据包到达 s1 时，找不到匹配规则，触发 <code>PACKET_IN</code> 报文上送控制器。</p>
<p>但由于控制器未安装流表或尚未学习路径，数据包被丢弃。因此 h1 与 h3 之间无法通信。</p>
<h3 id="思考题3：给s1添加一个流表，该流表的源地址为h1，目标地址为h3，此时尝试-ping，应-ping-不通。为什么？"><a href="#思考题3：给s1添加一个流表，该流表的源地址为h1，目标地址为h3，此时尝试-ping，应-ping-不通。为什么？" class="headerlink" title="思考题3：给s1添加一个流表，该流表的源地址为h1，目标地址为h3，此时尝试 ping，应 ping 不通。为什么？"></a>思考题3：给s1添加一个流表，该流表的源地址为h1，目标地址为h3，此时尝试 ping，应 ping 不通。为什么？</h3><p><code>ping</code> 命令依赖 IP 协议层，首次通信前，系统需通过 ARP 解析对方 IP 对应的 MAC 地址，因此第一步发出的实际是一个ARP 请求包：</p>
<ul>
<li>源 MAC：h1 的 MAC</li>
<li>目的 MAC：ff:ff:ff:ff:ff:ff（广播）</li>
<li>协议类型：ARP</li>
</ul>
<p>我们安装的那条流表只匹配了<code>dl_dst = h3 的 MAC</code>（单播），但 ARP 请求包的目标地址是 <code>ff:ff:ff:ff:ff:ff</code>（广播），所以该数据包并不会命中安装的流表规则。</p>
<p>没有匹配的流表项 → OVS 将包封装为 <code>PACKET_IN</code> → 发给控制器。</p>
<p><img src="image-20250517165945894.png"></p>
<p>Ryu 控制台打印说明大量 ARP 请求（广播）未被匹配流表。所有这些 <code>packet in</code> 日志都显示 <code>dl_dst = ff:ff:ff:ff:ff:ff</code>，即都是<strong>广播包</strong>。这些包没有命中任何流表项，被交换机上传到了控制器。</p>
<p>具体的顺序图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant h1</span><br><span class="line">    participant s1</span><br><span class="line">    participant Controller</span><br><span class="line">    participant h3</span><br><span class="line"></span><br><span class="line">    h1-&gt;&gt;s1: ARP Request (dl_dst = ff:ff:ff:ff:ff:ff)</span><br><span class="line">    alt 没有匹配流表</span><br><span class="line">        s1-&gt;&gt;Controller: Packet-In (dl_dst=broadcast)</span><br><span class="line">        Controller--&gt;&gt;s1: 无下发</span><br><span class="line">        s1--x h3: 丢弃</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="思考题4：为什么仅设置了-h1-广播的流表项，未设置-h3-广播的流表项，h3-h1-仍能ping通？"><a href="#思考题4：为什么仅设置了-h1-广播的流表项，未设置-h3-广播的流表项，h3-h1-仍能ping通？" class="headerlink" title="思考题4：为什么仅设置了 h1 广播的流表项，未设置 h3 广播的流表项，h3-&gt;h1 仍能ping通？"></a>思考题4：为什么仅设置了 h1 广播的流表项，未设置 h3 广播的流表项，h3-&gt;h1 仍能ping通？</h3><p>ping 的前置过程是 ARP，h1 向 h3 发起 ARP 请求时，由于已存在匹配广播地址的流表项，ARP 请求成功到达 h3。</p>
<p>而h3 回应的是单播 ARP Reply，该包到达控制器后，simple_switch_13 控制器学习了 h1 与 h3 的 MAC 地址和端口映射关系，并自动下发了对应的单播流表项。之后的 ping 通信即变为单播，因此即便未为 h3 配置广播流表，通信也能成功。</p>
<p>这表明只要单向广播通路建立，配合控制器的 MAC 学习机制，就可实现完整通信。</p>
<h2 id="实验过程中遇到的问题及解决办法-1"><a href="#实验过程中遇到的问题及解决办法-1" class="headerlink" title="实验过程中遇到的问题及解决办法"></a>实验过程中遇到的问题及解决办法</h2><p>在<strong>下发流表，流表匹配与数据包处理</strong>一节中，需要注意，<code>in_port</code> 和 <code>OUTPUT</code> 中的 <code>port</code> 设置也需要按照实际设置，这一点在实验指导书中没有提到，但是如果配置有误会导致实验失败。</p>
<p>我一开始给s1添加源地址h3，目标地址h1的流表时是这样写的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123; </span><br><span class="line">  &quot;dpid&quot;: 1, </span><br><span class="line">  &quot;priority&quot;: 100, </span><br><span class="line">  &quot;match&quot;: &#123; </span><br><span class="line">    &quot;in_port&quot;: 1, </span><br><span class="line">    &quot;dl_src&quot;: &quot;42:f6:00:b0:c6:6f&quot;, </span><br><span class="line">    &quot;dl_dst&quot;: &quot;b2:84:cc:df:e0:53&quot; </span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;actions&quot;: [&#123;&quot;type&quot;: &quot;OUTPUT&quot;, &quot;port&quot;: 2&#125;] </span><br><span class="line">&#125;&#x27; http://127.0.0.1:8080/stats/flowentry/add</span><br></pre></td></tr></table></figure>

<p>这样配置无法ping通。</p>
<p>查阅资料发现是端口设置错误。</p>
<p>使用以下命令查看各交换机端口编号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ovs-ofctl -O OpenFlow13 show s1</span><br></pre></td></tr></table></figure>

<p><img src="image-20250517153809609.png"></p>
<p>也即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1(s1-eth1)  → 对应 h1/h3 到 s1 的一端  </span><br><span class="line">2(s1-eth2)  → 对应 s1 到 s2/s3 的另一端</span><br></pre></td></tr></table></figure>

<p>修改h3 ➝ h1 的流表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123;</span><br><span class="line">  &quot;dpid&quot;: 1,</span><br><span class="line">  &quot;priority&quot;: 100,</span><br><span class="line">  &quot;match&quot;: &#123;</span><br><span class="line">    &quot;in_port&quot;: 2,</span><br><span class="line">    &quot;dl_src&quot;: &quot;42:f6:00:b0:c6:6f&quot;,</span><br><span class="line">    &quot;dl_dst&quot;: &quot;b2:84:cc:df:e0:53&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;actions&quot;: [&#123;&quot;type&quot;: &quot;OUTPUT&quot;, &quot;port&quot;: 1&#125;]</span><br><span class="line">&#125;&#x27; http://127.0.0.1:8080/stats/flowentry/add</span><br></pre></td></tr></table></figure>

<p>先使用指令删除原来的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123;&quot;dpid&quot;:1,&quot;match&quot;:&#123;&#125;&#125;&#x27; http://127.0.0.1:8080/stats/flowentry/delete</span><br></pre></td></tr></table></figure>

<p>重新配置后再次ping，h1-h3成功连通</p>
<p><img src="image-20250517160029615.png"></p>
<h2 id="实验心得-1"><a href="#实验心得-1" class="headerlink" title="实验心得"></a>实验心得</h2><p>通过本次实验，我深入理解并掌握了OpenFlow协议中的流表控制机制，了解了如何借助Ryu控制器对交换机流表进行动态管理。</p>
<p>实验的核心部分是流表操作与数据包处理。在默认的simple_switch_13控制器下，交换机会自动学习主机的MAC地址并下发流表。我通过<code>curl http://127.0.0.1:8080/stats/flow/1</code>以及<code>sudo ovs-ofctl -O OpenFlow13 dump-flows s1</code>等命令分别查看流表状态，逐步熟悉了各个字段（如match字段中的in_port、dl_src、dl_dst，actions字段中的输出端口等）的含义。</p>
<p>在删除流表项后，通过对pingall测试结果的分析，我体会到了流表配置对于网络通信路径的关键作用。尤其是在需要手动配置流表的阶段，我需要精确地写出match匹配条件和对应的actions输出动作。中间曾遇到由于端口号、MAC地址、方向错误导致的通信失败，但通过不断地验证和分析<code>ryu</code>终端的packet in输出，我最终成功实现了从h1到h3的点对点通信。</p>
<p>总体而言，这次实验不仅加深了我对流表机制及OpenFlow协议的理解，更锻炼了我通过抓包、命令分析和逻辑推理来排查问题的能力。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenFlow/" rel="tag">OpenFlow</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SDN/" rel="tag">SDN</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/" rel="tag">现代交换原理</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/06/10/Spring-%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring-全栈开发学习笔记</a><a class="next" href="/2025/03/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/">操作系统课程设计</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://trenchance2022.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/trenchance.jpg"/></a><p>Give it your best shot.</p><a class="info-icon" href="https://github.com/trenchance2022" title="Github" target="_blank" style="margin-inline:5px"><img class="nofancybox" src="/img/github.png" style="width: 20px; height: 20px; margin-inline:5px; vertical-align: middle;"/></a><a class="info-icon" href="https://b23.tv/CPgDyCs" title="Bilibili" target="_blank" style="margin-inline:5px"><img class="nofancybox" src="/img/bilibili.png" style="width: 20px; height: 20px; margin-inline:5px; vertical-align: middle;"/></a><a class="info-icon" href="https://www.xiaohongshu.com/user/profile/62bece15000000001b027298" title="小红书" target="_blank" style="margin-inline:5px"><img class="nofancybox" src="/img/xiaohongshu.png" style="width: 20px; height: 20px; margin-inline:5px; vertical-align: middle;"/></a><a class="info-icon" href="mailto:renzg2004@126.com" title="Email" target="_blank" style="margin-inline:5px"><img class="nofancybox" src="/img/mail.png" style="width: 20px; height: 20px; margin-inline:5px; vertical-align: middle;"/></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/axios/" style="font-size: 15px;">axios</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" style="font-size: 15px;">计算机系统结构</a> <a href="/tags/SDN/" style="font-size: 15px;">SDN</a> <a href="/tags/OpenFlow/" style="font-size: 15px;">OpenFlow</a> <a href="/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/" style="font-size: 15px;">现代交换原理</a> <a href="/tags/SIP/" style="font-size: 15px;">SIP</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%AC%94%E8%AE%B0/">苍穹外卖笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/07/01/Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Java-基础语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/21/SIP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E9%AA%8C/">SIP协议实验</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">计算机系统结构笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/10/Spring-%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring-全栈开发学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/17/SDN%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8EOpenFlow%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">SDN基本原理与OpenFlow协议分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/">操作系统课程设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/01/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/">前端笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://github.com/trenchance2022" title="友链招募中" target="_blank">友链招募中</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Trenchance's Home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>